<!DOCTYPE html>
<html lang="en">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta http-equiv="Accept-CH" content="DPR, Viewport-Width, Width">
<link rel="icon" href=/images/andy.jpeg type="image/gif">


<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
      as="style"
      href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
>
<link rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
      media="print" onload="this.media='all'" />
<noscript>
  <link
          href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
          rel="stylesheet">
</noscript>


<link rel="stylesheet" href="/css/font.css" media="all">



<meta property="og:url" content="https://whywhom.github.io/blogs/android-interview-series-2024-part-2-android-intermediate/">
  <meta property="og:site_name" content="Andy&#39;s Blog">
  <meta property="og:title" content="Android intermediate">
  <meta property="og:description" content="Android Interview Series 2024 — Part 2">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2024-05-03T23:29:21+05:30">
    <meta property="article:modified_time" content="2024-05-03T23:29:21+05:30">
    <meta property="article:tag" content="Android">
    <meta property="article:tag" content="Interview">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Android intermediate">
  <meta name="twitter:description" content="Android Interview Series 2024 — Part 2">


<link rel="stylesheet" href="/bootstrap-5/css/bootstrap.min.css" media="all"><link rel="stylesheet" href="/css/header.css" media="all">
<link rel="stylesheet" href="/css/footer.css" media="all">


<link rel="stylesheet" href="/css/theme.css" media="all">

<style>
    :root {
        --text-color: #343a40;
        --text-secondary-color: #6c757d;
        --text-link-color: #007bff;
        --background-color: #eaedf0;
        --secondary-background-color: #64ffda1a;
        --primary-color: #007bff;
        --secondary-color: #f8f9fa;

         
        --text-color-dark: #e4e6eb;
        --text-secondary-color-dark: #b0b3b8;
        --text-link-color-dark: #ffffff;
        --background-color-dark: #18191a;
        --secondary-background-color-dark: #212529;
        --primary-color-dark: #ffffff;
        --secondary-color-dark: #212529;
    }
    body {
        font-size: 1rem;
        font-weight: 400;
        line-height: 1.5;
        text-align: left;
    }

    html {
        background-color: var(--background-color) !important;
    }

    body::-webkit-scrollbar {
        height: 0px;
        width: 8px;
        background-color: var(--background-color);
    }

    ::-webkit-scrollbar-track {
        border-radius: 1rem;
    }

    ::-webkit-scrollbar-thumb {
        border-radius: 1rem;
        background: #b0b0b0;
        outline: 1px solid var(--background-color);
    }

    #search-content::-webkit-scrollbar {
        width: .5em;
        height: .1em;
        background-color: var(--background-color);
    }
</style>



<meta name="description" content="Android Interview Series 2024 — Part 2">
<link rel="stylesheet" href="/css/single.css">


<script defer src="/fontawesome-6/all-6.4.2.js"></script>


  
  

  <title>
Android intermediate | Andy&#39;s Blog

  </title>
</head>

<body class="light">
  
  
<script>
    let localStorageValue = localStorage.getItem("pref-theme");
    let mediaQuery = window.matchMedia('(prefers-color-scheme: dark)').matches;

    switch (localStorageValue) {
        case "dark":
            document.body.classList.add('dark');
            break;
        case "light":
            document.body.classList.remove('dark');
            break;
        default:
            if (mediaQuery) {
                document.body.classList.add('dark');
            }
            break;
    }
</script>




<script>
    var prevScrollPos = window.pageYOffset;
    window.addEventListener("scroll", function showHeaderOnScroll() {
        let profileHeaderElem = document.getElementById("profileHeader");
        let currentScrollPos = window.pageYOffset;
        let resetHeaderStyle = false;
        let showNavBarOnScrollUp =  true ;
        let showNavBar = showNavBarOnScrollUp ? prevScrollPos > currentScrollPos : currentScrollPos > 0;
        if (showNavBar) {
            profileHeaderElem.classList.add("showHeaderOnTop");
        } else {
            resetHeaderStyle = true;
        }
        if(currentScrollPos === 0) {
            resetHeaderStyle = true;
        }
        if(resetHeaderStyle) {
            profileHeaderElem.classList.remove("showHeaderOnTop");
        }
        prevScrollPos = currentScrollPos;
    });
</script>



<header id="profileHeader">
    <nav class="pt-3 navbar navbar-expand-lg animate">
        <div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5">
            
            <a class="navbar-brand primary-font text-wrap" href="/">
                
                <img src="/images/andy.jpeg" width="30" height="30"
                    class="d-inline-block align-top">
                Andy&#39;s Blog
                
            </a>

            
                <div>
                    <input id="search" autocomplete="off" class="form-control mr-sm-2 d-none d-md-block" placeholder='Ctrl &#43; k to Search...'
                        aria-label="Search" oninput="searchOnChange(event)">
                </div>
            

            
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarContent"
                aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
                <svg aria-hidden="true" height="24" viewBox="0 0 16 16" version="1.1" width="24" data-view-component="true">
                    <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z"></path>
                </svg>
            </button>

            
            <div class="collapse navbar-collapse text-wrap primary-font" id="navbarContent">
                <ul class="navbar-nav ms-auto text-center">
                    
                        <li class="nav-item navbar-text d-block d-md-none">
                            <div class="nav-link">
                                <input id="search" autocomplete="off" class="form-control mr-sm-2" placeholder='Ctrl &#43; k to Search...' aria-label="Search" oninput="searchOnChange(event)">
                            </div>
                        </li>
                    

                    
                    <li class="nav-item navbar-text">
                        <a class="nav-link" href="/#about" aria-label="about">
                            About Me
                        </a>
                    </li>
                    

                    
                    <li class="nav-item navbar-text">
                        <a class="nav-link" href="/#experience"
                            aria-label="experience">
                            Experience
                        </a>
                    </li>
                    

                    
                    <li class="nav-item navbar-text">
                        <a class="nav-link" href="/#education"
                            aria-label="education">
                            Education
                        </a>
                    </li>
                    

                    

                    

                    

                    

                    
                    
                    
                    
                    <li class="nav-item navbar-text">
                        <a class="nav-link" href="/blogs" title="Blog posts">
                            
                            Blog
                        </a>
                    </li>
                    
                    
                    
                    
                    <li class="nav-item navbar-text">
                        <a class="nav-link" href="/gallery" title="Blog posts">
                            
                            Gallery
                        </a>
                    </li>
                    
                    
                    
                    
                    <li class="nav-item navbar-text">
                        <a class="nav-link" href="/resume" title="Resume">
                            
                            Resume
                        </a>
                    </li>
                    
                    

                    
                    <li class="nav-item navbar-text">
                        
                        <div class="text-center">
                            <button id="theme-toggle">
                                <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                                </svg>
                                <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="5"></circle>
                                    <line x1="12" y1="1" x2="12" y2="3"></line>
                                    <line x1="12" y1="21" x2="12" y2="23"></line>
                                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                                    <line x1="1" y1="12" x2="3" y2="12"></line>
                                    <line x1="21" y1="12" x2="23" y2="12"></line>
                                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                                </svg>
                            </button>
                        </div>
                    </li>
                    

                </ul>

            </div>
        </div>
    </nav>
</header>
<div id="content">
<section id="single">
  <div class="container">
    <div class="row justify-content-center">
      <div class="col-sm-12 col-md-12 col-lg-9">
        <div class="pr-lg-4">
          <div class="title mb-5">
            <h1 class="text-center mb-4">Android intermediate</h1>
            <div class="text-center">
              
                Anitaa Murthy
                <small>|</small>
              
              May 3, 2024

              
              <span id="readingTime">
                min read
              </span>
              
            </div>
          </div>
          
          <div class="featured-image">
            <img class="img-fluid mx-auto d-block" src="https://hdwallsbox.com/wallpapers/m/78/3d-android-logo-background-m77313.jpg" alt="Android intermediate">
          </div>
          
          <article class="page-content  p-2">
          <p>Here is the original article:</p>
<p><a href="https://proandroiddev.com/android-interview-series-2024-part-2-android-intermediate-472e0e787725">🔗 Android Interview Series 2024 — Part 2 (Android intermediate)</a></p>
<p>This article is published on ProAndroidDev and covers essential Android interview topics for 2024. 🚀</p>
<h5 id="1-what-are-android-architecture-components-and-why-are-they-useful">1. What are Android Architecture Components, and why are they useful?</h5>
<p>Android Architecture Components are a set of libraries introduced by Google to help developers design robust, testable, and maintainable Android applications. These libraries provide solutions to common problems that Android developers face, such as managing UI lifecycle changes and handling data persistence efficiently.</p>
<h5 id="2-how-do-android-architecture-components-help-in-managing-app-complexity">2. How do Android Architecture Components help in managing app complexity?</h5>
<ul>
<li><code>Lifecycle Awareness</code>: These components are lifecycle-aware, helping prevent memory leaks and crashes by automatically managing data updates with respect to the activity/fragment lifecycle.</li>
<li><code>Data Consistency</code>: ViewModel and LiveData help ensure that data is consistent across configuration changes, such as screen rotations, eliminating the need for manual handling in activities or fragments.</li>
<li><code>Testability</code>: The structure provided by architecture components encourages modularity, making it easier to write unit tests for each component.</li>
<li><code>Reduced Boilerplate</code>: With Room and other components, architecture components help reduce the amount of boilerplate code, making the codebase cleaner and easier to maintain.</li>
<li><code>Encourages MVVM Architecture</code>: These components naturally fit into the Model-View-ViewModel (MVVM) architecture, which is widely used in Android development for maintaining a clean separation between UI and data logic.</li>
</ul>
<h5 id="3-what-are-the-main-components-included-in-android-architecture-components">3. What are the main components included in Android Architecture Components?</h5>
<p>The primary components include:</p>
<ul>
<li><code>ViewModel</code>: Stores and manages UI-related data in a lifecycle-conscious way. It allows data to survive configuration changes like screen rotations, ensuring that UI data remains consistent without having to reload or recreate data unnecessarily.</li>
<li><code>LiveData</code>: An observable data holder class that’s lifecycle-aware. It ensures that the UI components only observe LiveData when they’re in an active state, helping to prevent memory leaks and avoid crashes from updates that occur when the UI is in the background.</li>
<li><code>Room</code>: A database library that provides an abstraction layer over SQLite, making it easier to manage local data. Room includes compile-time checks for SQL queries and simplifies working with databases by using annotations and eliminating the need for boilerplate SQL code.</li>
<li><code>Repository</code>: Although not an official library, a repository is a popular architectural pattern for abstracting data access. It acts as a single source of truth, managing data from various sources (local databases, network, etc.) and providing a clean API for data access.</li>
<li><code>Navigation Component</code>: Helps manage navigation within an app, supporting complex navigational patterns like bottom navigation, tab navigation, and side navigation drawers. It also includes safe-args to ensure type-safety in navigation.</li>
<li><code>WorkManager</code>: A library that handles scheduling background tasks in a reliable way. It’s especially useful for tasks that need guaranteed execution, like syncing data in the background.</li>
</ul>
<h5 id="4-what-is-a-lifecycleowner">4. What is a LifecycleOwner?</h5>
<p>A LifecycleOwner is an interface that represents an entity with an Android lifecycle. It is a component that has a defined lifecycle, such as an Activity or Fragment, which allows it to hold and observe other components that are aware of its lifecycle state (like LiveData or ViewModel). This helps manage resources efficiently and prevents memory leaks by only observing changes while the LifecycleOwner is in an active state.</p>
<h5 id="5-why-is-it-important-to-use-lifecycle-aware-components-in-android-development">5. Why is it important to use lifecycle-aware components in Android development?</h5>
<ul>
<li>Using LifecycleOwner with lifecycle-aware components (like LiveData) prevents memory leaks because observers are automatically removed when the lifecycle is no longer active, reducing the need for manual cleanup.</li>
<li>When a LifecycleOwner (e.g., an Activity) observes LiveData, updates to the UI occur only while the component is in an active state. If the component is stopped or destroyed, updates are automatically paused or detached.</li>
<li>With a LifecycleOwner, components can respond accurately to lifecycle changes, enabling a more consistent user experience (e.g., data is not lost when screen rotations occur).</li>
</ul>
<h5 id="6-what-is-the-purpose-of-the-viewmodel-class">6. What is the purpose of the ViewModel class?</h5>
<p>The ViewModel class in Android is a part of the Android Architecture Components and is designed to store and manage UI-related data in a lifecycle-conscious way. Its purpose is to hold data that is relevant to the UI and retain this data through configuration changes, such as screen rotations, avoiding the need to reload or re-fetch data every time an activity or fragment is recreated.</p>
<h5 id="7-how-does-viewmodel-help-in-managing-ui-related-data-during-configuration-changes">7. How does ViewModel help in managing UI-related data during configuration changes?</h5>
<ul>
<li>One of the primary benefits of ViewModel is that it survives configuration changes like screen rotations. This means that if an activity is recreated due to a configuration change, the ViewModel remains in memory and keeps the UI data intact, avoiding the need to reload data from scratch.</li>
<li>ViewModel helps to keep the UI controller (like Activity or Fragment) lean and focused on UI-related tasks only. The business logic and data handling are managed by the ViewModel, which improves code organization and makes it easier to maintain.</li>
<li>The ViewModel is lifecycle-aware and knows when an activity or fragment is destroyed. When a UI component is finished (e.g., activity is destroyed permanently), the ViewModel’s data is cleared, releasing resources and preventing memory leaks.</li>
<li>Since the ViewModel does not contain any references to the UI elements (like View or Context), it can be tested independently of the UI. This makes it easier to unit test and verify the behavior of the ViewModel.</li>
</ul>
<h5 id="8-explain-the-relationship-between-viewmodel-and-savedstatehandle">8. Explain the relationship between ViewModel and SavedStateHandle.</h5>
<ul>
<li>A ViewModel stores and manages UI-related data in a lifecycle-aware manner, retaining data across configuration changes, such as screen rotations. However, if the app process is killed (e.g., due to low memory), data stored in a ViewModel is lost, as ViewModel does not retain its state when the app is killed and later restarted.</li>
<li>SavedStateHandle is a key-value map available in a ViewModel to store data that should survive process death.It can retain and restore small pieces of UI-related state data (like user input, scroll positions, or other data that should persist across app restarts).SavedStateHandle works in conjunction with the Android Saved State feature, leveraging onSaveInstanceState under the hood, allowing you to define data that should be saved and restored automatically.</li>
<li>When a ViewModel has a SavedStateHandle, it can store data that will be preserved not only through configuration changes but also across process death. This makes it useful for retaining critical UI state that the user expects to see restored if they return to the app after it was killed.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CounterViewModel</span>(<span style="color:#66d9ef">private</span> val savedStateHandle: SavedStateHandle) : ViewModel() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Define a key to store the counter value in SavedStateHandle</span>
</span></span><span style="display:flex;"><span>    companion object {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">const</span> val COUNTER_KEY <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;counter&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Retrieve the counter value from SavedStateHandle, or set to 0 if it&#39;s not set</span>
</span></span><span style="display:flex;"><span>    val counter: MutableLiveData<span style="color:#f92672">&lt;</span>Int<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> savedStateHandle.<span style="color:#a6e22e">getLiveData</span>(COUNTER_KEY, 0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Method to increment the counter</span>
</span></span><span style="display:flex;"><span>    fun <span style="color:#a6e22e">incrementCounter</span>() {
</span></span><span style="display:flex;"><span>        val updatedValue <span style="color:#f92672">=</span> (counter.<span style="color:#a6e22e">value</span> <span style="color:#f92672">?</span>: 0) <span style="color:#f92672">+</span> 1
</span></span><span style="display:flex;"><span>        counter.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> updatedValue
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Save the updated counter value to SavedStateHandle</span>
</span></span><span style="display:flex;"><span>        savedStateHandle<span style="color:#f92672">[</span>COUNTER_KEY<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> updatedValue
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="9-what-is-livedata-and-how-does-livedata-help-in-managing-ui-state">9. What is LiveData, and how does LiveData help in managing UI state?</h5>
<ul>
<li>LiveData is an observable data holder class that is lifecycle-aware, meaning it respects the lifecycle of the Android components (such as Activity or Fragment) that observe it.</li>
<li>By observing LiveData, UI components automatically receive updates when the data changes. This reactive approach allows developers to decouple UI components from data sources, leading to a cleaner architecture where the data layer notifies the UI without explicit callbacks.</li>
<li>LiveData works seamlessly with ViewModel, which survives configuration changes like screen rotations. This means that the UI retains its state and stays up-to-date with the latest data without reloading or re-fetching it.</li>
<li>LiveData is useful for managing asynchronous data sources, such as data fetched from a network or a database. Once data is fetched, it can be set in LiveData, which notifies observers to update the UI automatically.</li>
</ul>
<h5 id="10-explain-the-difference-between-mutablelivedata-and-livedata">10. Explain the difference between MutableLiveData and LiveData.</h5>
<ul>
<li>LiveData is an immutable data holder class, meaning that once data is set in a LiveData object, it can only be observed but not modified. This immutability is enforced to provide a safe, read-only view of data, especially when you want to expose data from a ViewModel to be observed by UI components without allowing them to modify it.</li>
<li>MutableLiveData is a subclass of LiveData that allows data to be modified. Unlike LiveData, it provides setter methods (setValue() or postValue()), which enable changing the data held in the MutableLiveData object. MutableLiveData is typically used inside a ViewModel where you want to manage and update the data in response to events.</li>
</ul>
<h5 id="11-what-are-transformations-in-livedata-and-how-do-you-use-them">11. What are Transformations in LiveData, and how do you use them?</h5>
<p>Transformations in LiveData are utility methods provided by the Android Architecture Components that allow you to manipulate or transform the data held in one LiveData into another LiveData.</p>
<ul>
<li>map is used to apply a transformation function to each value in LiveData.</li>
<li>switchMap is helpful when the transformation depends on another LiveData that might change.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.lifecycle.LiveData
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.lifecycle.MutableLiveData
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.lifecycle.Transformations
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.lifecycle.ViewModel
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CounterViewModel</span> : ViewModel() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> val _counter <span style="color:#f92672">=</span> MutableLiveData<span style="color:#f92672">&lt;</span>Int<span style="color:#f92672">&gt;</span>().<span style="color:#a6e22e">apply</span> { value <span style="color:#f92672">=</span> 0 }
</span></span><span style="display:flex;"><span>    val counter: LiveData<span style="color:#f92672">&lt;</span>Int<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">get</span>() <span style="color:#f92672">=</span> _counter
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Transform the counter value into a formatted string</span>
</span></span><span style="display:flex;"><span>    val counterText: LiveData<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Transformations.<span style="color:#a6e22e">map</span>(_counter) { count <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Counter Value: $count&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fun <span style="color:#a6e22e">incrementCounter</span>() {
</span></span><span style="display:flex;"><span>        _counter.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> (_counter.<span style="color:#a6e22e">value</span> <span style="color:#f92672">?</span>: 0) <span style="color:#f92672">+</span> 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> val _userId <span style="color:#f92672">=</span> MutableLiveData<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span>    val userId: LiveData<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">get</span>() <span style="color:#f92672">=</span> _userId
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simulated repository method to fetch user details by ID</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> fun <span style="color:#a6e22e">getUserDetails</span>(userId: String): LiveData<span style="color:#f92672">&lt;</span>User<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Normally, this would be a call to a repository that fetches data from a database or network</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> MutableLiveData(User(userId, <span style="color:#e6db74">&#34;User Name for $userId&#34;</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Using switchMap to retrieve user details whenever userId changes</span>
</span></span><span style="display:flex;"><span>    val userDetails: LiveData<span style="color:#f92672">&lt;</span>User<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Transformations.<span style="color:#a6e22e">switchMap</span>(_userId) { id <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>        getUserDetails(id)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fun <span style="color:#a6e22e">setUserId</span>(id: String) {
</span></span><span style="display:flex;"><span>        _userId.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> id
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Data class for User details</span>
</span></span><span style="display:flex;"><span>data <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span>(val id: String, val name: String)
</span></span></code></pre></div><h5 id="12-explain-the-differences-between-mediatorlivedata-and-regular-livedata">12. Explain the differences between MediatorLiveData and regular LiveData.</h5>
<ul>
<li>LiveData is a lifecycle-aware, observable data holder class. It allows UI components to observe changes in data and automatically updates the UI when the data changes. It is primarily used for single-source observation, meaning it directly holds and manages data from one source. Once LiveData is observed, it provides the updated value to the UI component when the data changes.</li>
<li>MediatorLiveData is a subclass of LiveData that can observe multiple LiveData sources simultaneously. It acts as a “mediator” and can combine data from multiple sources or react to changes in one or more LiveData sources. MediatorLiveData is helpful for scenarios where you need to manage and observe data from multiple LiveData sources and produce a single, unified result. It allows developers to define custom transformation logic to handle the data from multiple sources and decide what should be emitted to observers.</li>
</ul>
<h5 id="13-how-would-you-implement-singleliveevent-to-handle-single-time-events">13. How would you implement SingleLiveEvent to handle single-time events?</h5>
<ul>
<li>LiveData is commonly used to observe data changes in a lifecycle-aware manner, but it has a limitation when handling single-time events. Events like navigation, showing a toast, or triggering a one-time action should only happen once. However, if the LiveData is observed again (like after a configuration change), it will re-emit the last value, causing the event to trigger multiple times.</li>
<li>To solve this issue, developers often implement a custom class called SingleLiveEvent. SingleLiveEvent is a LiveData subclass designed to handle events that should only be triggered once, such as displaying a message or navigating to another screen. It ensures that the event is only observed once, even if the observer&rsquo;s lifecycle changes.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.annotation.MainThread
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.lifecycle.LifecycleOwner
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.lifecycle.MutableLiveData
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.lifecycle.Observer
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.atomic.AtomicBoolean
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SingleLiveEvent</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> : MutableLiveData<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> val pending <span style="color:#f92672">=</span> AtomicBoolean(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@MainThread</span>
</span></span><span style="display:flex;"><span>    override fun <span style="color:#a6e22e">observe</span>(owner: LifecycleOwner, observer: Observer<span style="color:#f92672">&lt;</span>in T<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Observe the internal MutableLiveData</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">observe</span>(owner, { t <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pending.<span style="color:#a6e22e">compareAndSet</span>(<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>)) {
</span></span><span style="display:flex;"><span>                observer.<span style="color:#a6e22e">onChanged</span>(t)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@MainThread</span>
</span></span><span style="display:flex;"><span>    override fun <span style="color:#a6e22e">setValue</span>(value: T<span style="color:#f92672">?</span>) {
</span></span><span style="display:flex;"><span>        pending.<span style="color:#a6e22e">set</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">setValue</span>(value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// A method to call when there&#39;s no data (for events like showing a Toast)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@MainThread</span>
</span></span><span style="display:flex;"><span>    fun <span style="color:#a6e22e">call</span>() {
</span></span><span style="display:flex;"><span>        value <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="14-what-is-room-database-and-why-should-it-be-used-instead-of-sqlite-directly">14. What is Room Database, and why should it be used instead of SQLite directly?</h5>
<ul>
<li>Room Database is part of the Android Architecture Components and provides an abstraction layer over SQLite to make database interactions more robust, easier to use, and less error-prone.</li>
<li>One of the biggest advantages of Room is that it verifies SQL queries at compile time. This means if there’s a typo or an invalid SQL query, you’ll get an error before even running the app.</li>
<li>Room provides annotations (@Entity, @Dao, @Query, etc.) that reduce the need for boilerplate code, making database interactions more concise and readable.</li>
<li>Room is designed to work seamlessly with Android’s Architecture Components, including LiveData and ViewModel. This makes it easier to build lifecycle-aware applications, where data from the database can be observed and automatically update the UI.</li>
<li>Room provides a structured way to handle database versioning and migrations.</li>
<li>Room uses annotated Entity classes to represent database tables, allowing developers to work with Java/Kotlin objects instead of managing raw SQL statements and cursors.</li>
<li>With Room, unit testing is simpler because you can create an in-memory version of the database for tests. Room also provides a clear separation of concerns and better support for dependency injection, making testing more straightforward.</li>
</ul>
<h5 id="15-how-does-room-handle-database-migrations">15. How does Room handle database migrations?</h5>
<p>Room uses migration strategies that allow you to define transformations to bring the database schema from one version to the next. When you increment the version number of the Room database, you must also specify how to migrate from the old schema to the new schema to avoid errors and ensure data consistency.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> android.content.Context
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.room.*
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.sqlite.db.SupportSQLiteDatabase
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.lifecycle.LiveData
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.atomic.AtomicInteger
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Entity representing the &#39;user_table&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Entity</span>(tableName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;user_table&#34;</span>)
</span></span><span style="display:flex;"><span>data <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@PrimaryKey</span>(autoGenerate <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>) val id: Int <span style="color:#f92672">=</span> 0,
</span></span><span style="display:flex;"><span>    val name: String,
</span></span><span style="display:flex;"><span>    val email: String,
</span></span><span style="display:flex;"><span>    val age: Int <span style="color:#75715e">// New column added in version 2</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// DAO Interface for accessing &#39;user_table&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Dao</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">UserDao</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Insert</span>(onConflict <span style="color:#f92672">=</span> OnConflictStrategy.<span style="color:#a6e22e">IGNORE</span>)
</span></span><span style="display:flex;"><span>    suspend fun <span style="color:#a6e22e">insert</span>(user: User)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Query</span>(<span style="color:#e6db74">&#34;SELECT * FROM user_table ORDER BY name ASC&#34;</span>)
</span></span><span style="display:flex;"><span>    fun <span style="color:#a6e22e">getAllUsers</span>(): LiveData<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>User<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Delete</span>
</span></span><span style="display:flex;"><span>    suspend fun <span style="color:#a6e22e">delete</span>(user: User)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Room Database with migration from version 1 to version 2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Database</span>(entities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>User::<span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">],</span> <span style="color:#a6e22e">version</span> <span style="color:#f92672">=</span> 2, exportSchema <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserDatabase</span> : RoomDatabase() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">abstract</span> fun <span style="color:#a6e22e">userDao</span>(): UserDao
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    companion object {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@Volatile</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> INSTANCE: UserDatabase<span style="color:#f92672">?</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Migration object to add &#39;age&#39; column to the &#39;user_table&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> val MIGRATION_1_2 <span style="color:#f92672">=</span> object : Migration(1, 2) {
</span></span><span style="display:flex;"><span>            override fun <span style="color:#a6e22e">migrate</span>(database: SupportSQLiteDatabase) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Add the new &#39;age&#39; column with a default value to existing rows</span>
</span></span><span style="display:flex;"><span>                database.<span style="color:#a6e22e">execSQL</span>(<span style="color:#e6db74">&#34;ALTER TABLE user_table ADD COLUMN age INTEGER NOT NULL DEFAULT 0&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Singleton pattern to get a single instance of UserDatabase</span>
</span></span><span style="display:flex;"><span>        fun <span style="color:#a6e22e">getDatabase</span>(context: Context): UserDatabase {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> INSTANCE <span style="color:#f92672">?</span>: <span style="color:#66d9ef">synchronized</span>(<span style="color:#66d9ef">this</span>) {
</span></span><span style="display:flex;"><span>                val instance <span style="color:#f92672">=</span> Room.<span style="color:#a6e22e">databaseBuilder</span>(
</span></span><span style="display:flex;"><span>                    context.<span style="color:#a6e22e">applicationContext</span>,
</span></span><span style="display:flex;"><span>                    UserDatabase::<span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">.</span><span style="color:#a6e22e">java</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;user_database&#34;</span>
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">addMigrations</span>(MIGRATION_1_2) <span style="color:#75715e">// Register the migration here</span>
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">build</span>()
</span></span><span style="display:flex;"><span>                INSTANCE <span style="color:#f92672">=</span> instance
</span></span><span style="display:flex;"><span>                instance
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="16-how-do-you-manage-relationships-eg-one-to-many-in-room">16. How do you manage relationships (e.g., one-to-many) in Room?</h5>
<p>Room supports relationships using embedded classes and the @Relation annotation to define how entities are connected. For example, in a one-to-many relationship, you might have a User entity that can have multiple Address entries.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.room.*
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Entity</span>(tableName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;user_table&#34;</span>)
</span></span><span style="display:flex;"><span>data <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@PrimaryKey</span> val userId: Long,
</span></span><span style="display:flex;"><span>    val userName: String
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Entity</span>(
</span></span><span style="display:flex;"><span>    tableName <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;address_table&#34;</span>,
</span></span><span style="display:flex;"><span>    foreignKeys <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>ForeignKey(
</span></span><span style="display:flex;"><span>        entity <span style="color:#f92672">=</span> User::<span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">,</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">parentColumns</span> <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;userId&#34;</span><span style="color:#f92672">]</span>,
</span></span><span style="display:flex;"><span>        childColumns <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;userOwnerId&#34;</span><span style="color:#f92672">]</span>,
</span></span><span style="display:flex;"><span>        onDelete <span style="color:#f92672">=</span> ForeignKey.<span style="color:#a6e22e">CASCADE</span>
</span></span><span style="display:flex;"><span>    )<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>data <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Address</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@PrimaryKey</span>(autoGenerate <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>) val addressId: Long <span style="color:#f92672">=</span> 0,
</span></span><span style="display:flex;"><span>    val address: String,
</span></span><span style="display:flex;"><span>    val userOwnerId: Long <span style="color:#75715e">// Foreign key referencing User</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserWithAddresses</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Embedded</span> val user: User,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Relation</span>(
</span></span><span style="display:flex;"><span>        parentColumn <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;userId&#34;</span>,
</span></span><span style="display:flex;"><span>        entityColumn <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;userOwnerId&#34;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    val addresses: List<span style="color:#f92672">&lt;</span>Address<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Dao</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">UserDao</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transaction</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Query</span>(<span style="color:#e6db74">&#34;SELECT * FROM user_table WHERE userId = :userId&#34;</span>)
</span></span><span style="display:flex;"><span>    fun <span style="color:#a6e22e">getUserWithAddresses</span>(userId: Long): LiveData<span style="color:#f92672">&lt;</span>UserWithAddresses<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="17-what-is-the-difference-between-data-binding-and-view-binding">17. What is the difference between Data Binding and View Binding?</h5>
<ul>
<li>View Binding is a straightforward, lightweight tool that generates binding classes for each XML layout file. It allows you to access views directly in code without needing findViewById. It’s simple to use, as it automatically generates a binding class for each XML file, where each view can be referenced directly through its ID.</li>
<li>Data Binding allows you to bind data directly to the XML layout, enabling a reactive, two-way binding setup where the UI automatically updates in response to changes in data. It supports binding expressions, observable properties, and two-way data binding, which can simplify UI updates in complex applications, especially those using MVVM architecture.</li>
</ul>
<h5 id="18-how-do-you-handle-data-binding-errors-during-compile-time">18. How do you handle data-binding errors during compile time?</h5>
<ul>
<li>Handling data-binding errors during compile time can be challenging, as these errors often arise from incorrect expressions, type mismatches, or improperly defined variables in the XML layout.</li>
<li>To proactively handle data-binding errors, developers can enable ViewModel validation and use @Bindable annotations for properties that need two-way binding, ensuring proper communication between the XML and ViewModel.</li>
<li>Another best practice is to use @BindingAdapter methods for custom binding logic, as this keeps the code cleaner and reduces the risk of XML syntax errors.</li>
</ul>
<h5 id="19-what-is-the-navigation-component-and-how-does-the-navigation-component-simplify-fragment-transactions">19. What is the Navigation Component, and how does the Navigation Component simplify Fragment transactions?</h5>
<p>The Navigation Component provides a cohesive framework to define navigation paths, handle fragment transactions, and manage back stacks.
The Navigation Component enables developers to define all app navigation in a single navigation graph XML file, making it easy to visualize the app’s flow. This file contains Destinations (screens like activities and fragments) and Actions (connections between screens), allowing you to specify navigation paths, arguments, and transition animations in one place.
The Navigation Component simplifies fragment transactions by automatically handling many complexities of fragment management, such as back-stack handling and lifecycle awareness. Instead of manually managing fragment transactions with FragmentManager, developers can use the NavController to navigate between fragments with a single command, such as findNavController().navigate(R.id.destinationFragment). It eliminates the need for boilerplate code, making fragment navigation more readable and less error-prone.</p>
<h5 id="20-explain-the-difference-between-safe-args-and-implicit-intents">20. Explain the difference between Safe Args and implicit intents.</h5>
<p>Safe Args is specifically part of the Navigation Component, designed to facilitate safe and type-checked data passing between destinations defined in a navigation graph, typically between fragments or activities.
Safe Args generates argument classes for each destination, allowing developers to pass data using strongly typed methods, reducing the risk of runtime errors like missing or mismatched arguments.
This approach makes navigation code more predictable, as it ensures that all required arguments are passed correctly at compile time.
Implicit intents, on the other hand, are used to request actions from other applications or components within Android without specifying the exact component (activity, service, etc.) that should handle the request. For example, an implicit intent can be used to open a URL in a web browser or share content via available apps.</p>
<h5 id="21-how-do-you-handle-deep-linking-with-the-navigation-component">21. How do you handle deep linking with the Navigation Component?</h5>
<p>To handle deep linking with the Navigation Component, you define deep links within the navigation graph, which allows your app to open specific destinations directly via a URL or URI. This feature makes it easy to navigate to particular fragments or activities directly from external sources like notifications, emails, or web links.
When the app receives an intent with a matching deep link, the Navigation Component automatically handles the navigation and populates any arguments specified in the URI.</p>
<h5 id="22-what-are-some-best-practices-for-working-with-the-navigation-component">22. What are some best practices for working with the Navigation Component?</h5>
<p>Aim to use one main activity with multiple fragments managed by the Navigation Component. This approach reduces complexity and takes full advantage of fragment-based navigation with a single NavController.
Use Safe Args to pass data between destinations. Safe Args generates type-safe classes for arguments, reducing the risk of runtime errors and ensuring compile-time checks.
Keep the navigation graph organized and avoid deeply nested or overly complex navigation paths. If the app has separate flows, consider using multiple navigation graphs or nested graphs to keep each graph manageable.
Configure up and back navigation to respect the back stack. Use app:defaultNavHost=&ldquo;true&rdquo; for the NavHostFragment in the main activity layout to handle system back button presses correctly.
Define deep links in the navigation graph for screens that should be accessible from external sources (like notifications or URLs). This simplifies external navigation and ensures that deep links can bring users to the correct destination with the right data.
Set up custom animations in the navigation graph to provide smooth transitions between fragments, enhancing the user experience. Use shared element transitions when moving between fragments that share visual elements.
Use popUpTo and popUpToInclusive attributes in actions to clear unnecessary fragments from the back stack, preventing stack overflow and reducing memory usage.</p>
<h5 id="23-what-is-the-purpose-of-the-paging-library">23. What is the purpose of the Paging library?</h5>
<p>The Paging library in Android simplifies loading large data sets by loading and displaying data in chunks or “pages” rather than all at once, thus optimizing memory usage and performance. This approach is especially helpful for lists that fetch data from local databases or remote sources, ensuring smooth scrolling and efficient resource use.</p>
<h5 id="24-explain-the-differences-between-pagingsource-pagingdata-and-pagingadapter">24. Explain the differences between PagingSource, PagingData, and PagingAdapter.</h5>
<p>PagingSource: Defines how to load data pages from a data source (e.g., database or network).
PagingData: A container holding paginated data that the UI can observe and render.
PagingAdapter: A RecyclerView adapter designed to submit PagingData to the UI and handle diffing and display of data items.
class MyPagingSource : PagingSource&lt;Int, MyData&gt;() { /* Load data */ }
val pagingData = Pager(PagingConfig(pageSize = 20)) { MyPagingSource() }.flow
adapter.submitData(lifecycle, pagingData)</p>
<h5 id="25-how-does-the-paging-library-handle-data-loading-state-eg-loading-error-empty">25. How does the Paging library handle data loading state (e.g., loading, error, empty)?</h5>
<p>The Paging library uses LoadState to track data states: LoadState.Loading, LoadState.Error, and LoadState.NotLoading. Observing these states allows the UI to react appropriately, like showing a loading spinner or error message.</p>
<p>adapter.loadStateFlow.collect { loadStates -&gt;
when (val state = loadStates.refresh) {
is LoadState.Loading -&gt; showLoading()
is LoadState.Error -&gt; showError(state.error)
is LoadState.NotLoading -&gt; showContent()
}
}</p>
<h5 id="26-how-would-you-implement-a-refresh-mechanism-with-the-paging-library">26. How would you implement a refresh mechanism with the Paging library?</h5>
<p>You can implement a refresh by calling adapter.refresh() on the PagingAdapter, which reloads data from the start.</p>
<p>refreshButton.setOnClickListener { adapter.refresh() }</p>
<h5 id="27-whats-the-purpose-of-remotemediator-in-the-paging-library">27. What’s the purpose of RemoteMediator in the Paging library?</h5>
<p>RemoteMediator can fetch data from a remote source, typically an API, and store it in a local database. This cached data can then be loaded by the PagingSource, allowing the app to access previously loaded pages of data offline.
It manages boundary conditions for loading additional data. For example, it will trigger network requests for loading more items when the user scrolls to the end of the list or when more data is required from the server.
It enables the paging library to keep the locally cached data synchronized with remote data while ensuring that you’re not repeatedly loading the same pages.
RemoteMediator also handles various load states (e.g., Loading, Success, Error) and propagates them to the UI, providing a better user experience by indicating loading progress or errors.</p>
<h5 id="28-what-is-workmanager-and-when-should-it-be-used">28. What is WorkManager, and when should it be used?</h5>
<p>WorkManager is an Android library designed to handle background tasks that need to be guaranteed to run, even if the app is closed or the device is restarted. It&rsquo;s the recommended API for managing persistent, deferrable, and guaranteed background tasks in Android.</p>
<p>Tasks can be set to run only under specific conditions, such as when the device is connected to Wi-Fi, has sufficient battery level, or is charging.
Automatically retries tasks if they fail, based on exponential backoff.
Supports chaining and combining multiple tasks with dependencies.
You can schedule one-off or repeating tasks.</p>
<h5 id="29-explain-the-differences-between-workmanager-jobscheduler-and-alarmmanager">29. Explain the differences between WorkManager, JobScheduler, and AlarmManager.</h5>
<p>WorkManager: Used for deferrable, guaranteed background tasks that need to complete even if the app or device restarts. Used for tasks that should be guaranteed to run eventually (e.g., uploading logs, syncing data) and support constraints like battery level, network connectivity, etc.
JobScheduler: Schedules jobs to be run at a later time or under certain conditions (introduced in Android API 21). Used for background tasks that don’t need immediate execution and can wait for conditions (e.g., network connectivity, idle state).
AlarmManager: Used to trigger actions at exact times or after a specific duration. Suitable for time-sensitive tasks. Best for exact timing requirements where you need tasks to be triggered at a specific time or interval (e.g., scheduling daily alarms).</p>
<h5 id="30-describe-the-different-types-of-work-requests-in-workmanager">30. Describe the different types of work requests in WorkManager.</h5>
<p>WorkManager supports three types of work requests:</p>
<p>OneTimeWorkRequest: Executes a task once, ideal for one-off background tasks like a single data sync or upload. This is the most commonly used work request for tasks that don’t need repetition.
val oneTimeRequest = OneTimeWorkRequestBuilder<MyWorker>().build() WorkManager.getInstance(context).enqueue(oneTimeRequest)
PeriodicWorkRequest: Executes tasks on a recurring basis with a minimum interval of 15 minutes. It’s useful for tasks like daily backups or routine data sync.
val periodicRequest = PeriodicWorkRequestBuilder<MyWorker>(15, TimeUnit.MINUTES).build() WorkManager.getInstance(context).enqueue(periodicRequest)
UniqueWorkRequest: Allows you to enqueue a work request with a unique name, helping to avoid duplication. You can specify how to handle existing work if a request with the same name is already queued (e.g., REPLACE, KEEP).</p>
<h5 id="31-how-can-you-chain-multiple-work-requests-in-workmanager">31. How can you chain multiple work requests in WorkManager?</h5>
<p>In WorkManager, you can chain multiple work requests to ensure they run sequentially or based on complex dependencies. This is done using WorkContinuation.</p>
<p>val downloadWork = OneTimeWorkRequestBuilder<DownloadWorker>().build()
val processWork = OneTimeWorkRequestBuilder<ProcessWorker>().build()
val uploadWork = OneTimeWorkRequestBuilder<UploadWorker>().build()</p>
<p>WorkManager.getInstance(context)
.beginWith(downloadWork) // Starts with download work
.then(processWork)        // Chains process work after download
.then(uploadWork)         // Chains upload work after processing
.enqueue()</p>
<h5 id="32-what-are-the-limitations-of-workmanager-and-when-should-you-consider-alternatives">32. What are the limitations of WorkManager, and when should you consider alternatives?</h5>
<p>While WorkManager is powerful, it has a few limitations:</p>
<p>Minimum interval for periodic work is 15 minutes, which makes it unsuitable for tasks that need frequent execution.
Exact timing is not guaranteed, as WorkManager is optimized for battery and resource efficiency, so it may defer work based on system conditions.
Device constraints may cause WorkManager to postpone tasks until conditions are favorable (e.g., network availability).
Alternatives to consider:</p>
<p>JobScheduler for background tasks that don’t require precise timing but do need to respect device constraints, especially on API 21+.
AlarmManager if exact timing is critical for tasks (e.g., notifications at a specific time).
Firebase JobDispatcher (deprecated) for high-priority background tasks.</p>
<h5 id="33-what-is-dependency-injection-di-in-android">33. What is Dependency Injection (DI) in Android?</h5>
<p>Dependency Injection (DI) is a design pattern that enables objects or classes to be provided with their dependencies from an external source rather than creating them internally. In Android, DI simplifies dependency management, improves code readability, and makes testing easier by allowing mock dependencies to be injected. Popular DI frameworks like Dagger and Hilt (a Dagger extension) automate dependency injection, reducing boilerplate code and handling the dependency lifecycle.</p>
<p>Checkout this article by yours truly to find out more details about Hilt :)</p>
<h5 id="34-what-is-datastore-and-how-is-it-different-from-sharedpreferences">34. What is DataStore, and how is it different from SharedPreferences?</h5>
<p>DataStore is a data storage solution introduced in Android to replace SharedPreferences, providing a more robust and scalable way to store data, especially for asynchronous operations. There are two types of DataStore: Preferences DataStore and Proto DataStore.
Preferences DataStore: Stores simple key-value pairs, similar to SharedPreferences, but with improved data handling and thread safety.
Proto DataStore: Stores structured data using Protocol Buffers, ideal for complex data models.
DataStore operates asynchronously, preventing blocking the main thread.
DataStore is designed to work with Kotlin Coroutines, making it more efficient for modern Android applications.
DataStore guarantees data consistency and is safe to use across multiple threads.</p>
<h5 id="35-how-do-you-handle-large-data-sets-in-android-to-avoid-memory-issues">35. How do you handle large data sets in Android to avoid memory issues?</h5>
<p>Pagination: Use the Paging library to load data in chunks, displaying only a subset at a time to avoid loading the entire dataset into memory.
Use RecyclerView instead of ListView as it efficiently recycles views, reducing memory usage.</p>
<h5 id="36-how-would-you-handle-asynchronous-tasks-in-android">36. How would you handle asynchronous tasks in Android?</h5>
<p>Android provides several ways to handle asynchronous tasks:</p>
<p>Coroutines: Coroutines allow developers to handle asynchronous tasks in a sequential and readable manner. Using launch or async with Dispatchers.IO or Dispatchers.Default is common for background tasks
AsyncTask (Deprecated): Previously used for background tasks, but no longer recommended due to better alternatives like coroutines.
WorkManager: For tasks that require guaranteed execution, even if the app is closed or the device restarts.
RxJava: An alternative to coroutines, providing a powerful functional approach to handle asynchronous tasks.</p>
<h5 id="37-explain-how-you-can-prevent-memory-leaks-in-android">37. Explain how you can prevent memory leaks in Android.</h5>
<p>Memory leaks occur when objects that are no longer needed remain in memory, leading to increased memory usage. Techniques to prevent memory leaks include:</p>
<p>Avoid Long-lived Context References: Do not hold references to Activity or Context in non-UI classes (e.g., in singleton objects).
Use Weak References: For large objects that are accessed occasionally, use WeakReference to avoid keeping them in memory unnecessarily.
Lifecycle-aware Components: Use ViewModel and LiveData to manage data across configuration changes, avoiding Activity and Fragment references that can lead to leaks.
Use LeakCanary: A powerful tool for detecting memory leaks in real-time, helping identify and fix leaks during development.</p>
<h5 id="38-how-do-you-handle-large-image-files-efficiently-in-android">38. How do you handle large image files efficiently in Android?</h5>
<p>Image Compression: Resize and compress images before loading them, reducing the memory footprint.
Use libraries like Glide, Picasso, or Coil, which handle caching, compression, and efficient loading.
Cache frequently used images to reduce memory consumption and speed up loading.
Use vector images for icons and simple graphics instead of large bitmaps, and consider modern formats like WebP.</p>
<h5 id="39-what-is-an-application-not-responding-anr-error-and-how-can-you-prevent-them-from-occurring-in-an-app">39. What is an Application Not Responding (ANR) error, and how can you prevent them from occurring in an app?</h5>
<p>An ANR (Application Not Responding) error occurs when the main thread is blocked for more than five seconds, preventing the app from responding to user inputs. Common causes include performing long-running operations on the main thread, such as file I/O, database queries, or network requests.</p>
<p>To prevent ANR errors:</p>
<p>Run Tasks on Background Threads: Use coroutines or AsyncTask (in older apps) to move time-consuming tasks off the main thread.
Use Handlers and HandlerThread: For tasks that need to communicate with the main thread, use Handler with a background HandlerThread.
Optimize Loops and Heavy Calculations: If your app needs to perform complex calculations, optimize the logic to reduce execution time and run it in a background thread.
Avoid Blocking Operations in UI Lifecycle Callbacks: Avoid blocking calls in lifecycle methods like onCreate or onResume. Initialize heavy resources asynchronously.</p>
<h5 id="40-what-is-the-android-build-process-and-what-are-its-main-stages">40. What is the Android build process, and what are its main stages?</h5>
<p>The Android build process is a series of steps that convert source code, resources, and configuration files into an installable Android application package (APK). The main stages of the build process include:</p>
<p>Compile: This stage compiles the Java/Kotlin code into bytecode. The Android Gradle plugin compiles the code using the Java Compiler (javac) or Kotlin Compiler.
Resource Processing: Resources (layouts, images, strings, etc.) are processed and compiled into a binary format. The Android Asset Packaging Tool (AAPT) handles this stage, generating the R.java file that maps resource IDs.
Linking: In this stage, the compiled code and processed resources are linked together. The build system merges these elements and prepares them for packaging.
Packaging: Finally, the APK is generated, containing all compiled code, resources, and manifest files, ready for installation on Android devices.</p>
<h5 id="41-can-you-explain-the-difference-between-build-variants-and-product-flavors-in-android">41. Can you explain the difference between build variants and product flavors in Android?</h5>
<p>Build Variants: A combination of a build type (like debug or release) and product flavor. Each variant can have its own settings and behaviors, allowing developers to customize builds based on different requirements. For example, if you have a debug build type and a paid product flavor, you would get a paidDebug variant.
Product Flavors: These are different versions of your app that can be developed using the same codebase, typically used for creating free and paid versions, or variants for different markets. Each flavor can define its own resources and configurations. For instance, you might have flavors like free and paid, each with different features.</p>
<h5 id="42-what-is-gradle-and-why-is-it-used-in-the-android-build-process">42. What is Gradle, and why is it used in the Android build process?</h5>
<p>Gradle is a powerful build automation tool used in the Android development ecosystem to manage dependencies, compile code, run tests, and package applications. Its flexibility allows developers to define custom build configurations, automate tasks, and manage complex build processes efficiently.
Gradle serves as the foundation for the build system. It allows developers to configure build types, product flavors, and dependencies using a Groovy or Kotlin DSL (Domain Specific Language). Gradle’s incremental build capabilities also help reduce build times by only compiling code that has changed since the last build.</p>
<h5 id="43-what-are-gradle-tasks-and-how-are-they-used-in-the-build-process">43. What are Gradle tasks, and how are they used in the build process?</h5>
<p>Gradle tasks are units of work that Gradle performs when building your project. Each task represents a specific action, such as compiling code, packaging an APK, or running tests. Tasks can be built-in (provided by the Android Gradle plugin) or custom (defined by developers).</p>
<h5 id="44-how-would-you-customize-the-build-process-using-gradle-scripts">44. How would you customize the build process using Gradle scripts?</h5>
<p>Customizing the build process in Android can be achieved through Gradle scripts by adding custom tasks, modifying existing tasks, or adjusting project properties. You can create custom tasks to automate repetitive actions or to perform additional checks during the build process.</p>
<p>For example, if you want to copy assets after building, you could define a task like this:</p>
<p>task copyAssets(type: Copy) {
from &lsquo;src/main/assets&rsquo;
into &lsquo;build/outputs/assets&rsquo;
}</p>
<p>preBuild.dependsOn(copyAssets) // Making the copyAssets task run before the preBuild task</p>
<h5 id="45-what-is-the-difference-between-implementation-api-and-compileonly-dependencies-in-gradle">45. What is the difference between implementation, api, and compileOnly dependencies in Gradle?</h5>
<p>implementation: This dependency is only available to the module where it is declared and is not exposed to other modules that depend on it. This is useful for internal dependencies that should not leak out.
api: Dependencies declared with api are available to both the module where they are declared and any other module that depends on this module. Use api for libraries that need to be exposed to consumers.
compileOnly: This dependency is only available at compile time, meaning it is not included in the final APK. It’s used for dependencies required only during compilation, like annotation processors or provided libraries.
dependencies {
implementation &lsquo;com.google.code.gson:gson:2.8.8&rsquo;
api &lsquo;com.squareup.okhttp3:okhttp:4.9.2&rsquo;
compileOnly &lsquo;javax.annotation:javax.annotation-api:1.3.2&rsquo;
}</p>
<h5 id="46-can-you-explain-the-purpose-of-proguard-and-r8-in-the-android-build-process">46. Can you explain the purpose of ProGuard and R8 in the Android build process?</h5>
<p>ProGuard and R8 are tools used for code shrinking and obfuscation in Android applications.</p>
<p>ProGuard: A tool that has been traditionally used for code shrinking and obfuscation in Android. It works by analyzing the bytecode, removing unused classes and methods, and renaming classes and fields to shorter names.
R8: Introduced as a replacement for ProGuard, R8 performs all the functions of ProGuard but is more efficient and faster. It combines the shrinking and optimization processes, resulting in smaller APK sizes with better performance.
Both tools can be configured in the build.gradle file, and R8 is enabled by default in Android projects.
android {
buildTypes {
release {
minifyEnabled true
proguardFiles getDefaultProguardFile(&lsquo;proguard-android-optimize.txt&rsquo;), &lsquo;proguard-rules.pro&rsquo;
}
}
}</p>
<h5 id="47-what-are-build-types-in-android-and-what-are-the-default-types-provided">47. What are build types in Android, and what are the default types provided?</h5>
<p>Build types in Android define different configurations for building an app, typically used to differentiate between development and production versions. The default build types provided by the Android Gradle plugin are:</p>
<p>debug: This type is used during development and includes debug symbols and additional logging features. It enables testing and debugging of the app.
release: This type is optimized for production use, removing debugging information and enabling code shrinking and obfuscation. It should be used to generate the final APK or app bundle for distribution.
You can also define custom build types based on your project requirements.</p>
<h5 id="48-how-does-the-android-asset-packaging-tool-aapt-work-in-the-build-process">48. How does the Android Asset Packaging Tool (AAPT) work in the build process?</h5>
<p>The Android Asset Packaging Tool (AAPT) is a crucial component in the Android build process that handles the packaging of app resources into an APK. It compiles resources such as XML files, images, and other assets, generating a binary representation that the Android system can understand. AAPT also generates the R.java file, which is a reference for accessing resources in the code.</p>
<p>During the build process, AAPT processes resource directories, merging resources from different sources (like libraries) and ensuring that resources are unique. It then packages these resources into the APK, along with compiled code and manifest files.</p>
<h5 id="49-how-can-you-improve-the-build-speed-in-android">49. How can you improve the build speed in Android?</h5>
<p>Some effective strategies include:</p>
<p>Enable Gradle Daemon: Using the Gradle Daemon can speed up builds by keeping the Gradle process running in the background.
org.gradle.daemon=true
Enable Parallel Builds: Running tasks in parallel can reduce build times, especially in large projects.
org.gradle.parallel=true
Configure Incremental Builds: Ensure that only modified files are rebuilt by using incremental compilation and caching mechanisms.
Use Build Caches: Gradle supports local and remote build caches, allowing tasks to reuse outputs from previous builds.
Minimize Resource Processing: Limit resource usage by optimizing image sizes and using vector graphics where possible.</p>
<h5 id="50-what-are-multidex-and-multidex-support-library-and-when-are-they-needed">50. What are multidex and multidex support library, and when are they needed?</h5>
<p>Multidex is a feature that allows an Android app to have multiple DEX files. This is necessary when the number of method references in an app exceeds the 65,536 limit imposed by the DEX format. Multidex support library provides tools and methods to manage and access multiple DEX files seamlessly.
To enable multidex support, you can add the following configuration in your build.gradle file:
android {
defaultConfig {
multiDexEnabled true
}
}
dependencies {
implementation &lsquo;com.android.support:multidex:1.0.3&rsquo;
}</p>
<h5 id="51-how-do-you-handle-versioning-in-the-android-build-process">51. How do you handle versioning in the Android build process?</h5>
<p>Versioning in the Android build process is crucial for tracking application releases and managing updates. It is defined in the build.gradle file using versionCode and versionName.</p>
<p>versionCode: An integer value representing the version of the application. This number must be incremented with each release and is used by the Android system to determine whether one version is more recent than another.
versionName: A user-friendly string representing the version name of the application (e.g., “1.0”, “2.1.3”). It does not have to be unique and can be used for display purposes.</p>
<h5 id="52-what-are-buildconfig-and-manifest-placeholders-and-how-are-they-used">52. What are BuildConfig and Manifest placeholders, and how are they used?</h5>
<p>BuildConfig is a class automatically generated by the Android build system that contains build-specific constants, such as the application ID, build type, and version information. It can be accessed directly in your Java or Kotlin code.
Manifest placeholders allow you to replace specific values in the AndroidManifest.xml at build time. This can be useful for customizing application IDs, API keys, or other configurations based on build types or flavors.</p>
<h5 id="53-how-do-you-generate-signed-apks-and-app-bundles-in-android">53. How do you generate signed APKs and app bundles in Android?</h5>
<p>To generate signed APKs or app bundles in Android, you can use Android Studio or Gradle command line. In Android Studio, you can navigate to Build &gt; Generate Signed Bundle/APK and follow the wizard to create a signed APK or app bundle. You will need to provide your keystore file and configure signing credentials.</p>
<p>Using Gradle command line, you can build a signed APK by running:</p>
<p>./gradlew assembleRelease
Ensure that you have configured signing information in your build.gradle file under the buildTypes section.</p>
<p>android {
signingConfigs {
release {
keyAlias &lsquo;my-key-alias&rsquo;
keyPassword &lsquo;my-key-password&rsquo;
storeFile file(&lsquo;my-keystore.jks&rsquo;)
storePassword &lsquo;my-store-password&rsquo;
}
}
buildTypes {
release {
signingConfig signingConfigs.release
}
}
}</p>
<h5 id="54-what-are-the-differences-between-an-apk-and-an-aab-android-app-bundle">54. What are the differences between an APK and an AAB (Android App Bundle)?</h5>
<p>APK (Android Package) and AAB (Android App Bundle) are both packaging formats for Android applications, but they serve different purposes:</p>
<p>APK: This is the traditional package format used for distributing and installing apps on Android devices. It contains all the app’s resources, code, and metadata in a single file. APKs are simple to distribute but can lead to larger download sizes since they include resources for all device configurations.
AAB: The Android App Bundle is a more efficient format introduced by Google Play. It allows developers to package their apps in a way that Google Play can optimize for each device configuration, delivering only the necessary code and resources. This results in smaller app sizes for end-users and supports features like dynamic delivery and on-demand resources.</p>
<h5 id="55-how-to-reduce-apk-size-in-android">55. How to reduce APK size in Android?</h5>
<p>Use ProGuard/R8: Enable code shrinking and obfuscation to remove unused code and resources.
Optimize Images: Use compressed image formats (like WebP) and reduce image resolutions for various screen densities.
Remove Unused Resources: Use resource shrinking to eliminate unused resources in the final APK.
Modularize the App: Split the app into multiple modules and load only necessary parts, using features like dynamic delivery.
Use Android App Bundle (AAB): Transition to AAB format for optimized delivery through Google Play, ensuring users download only the necessary code and resources.</p>
<h5 id="56-what-is-the-purpose-of-the-android-profiler-and-what-are-its-main-components">56. What is the purpose of the Android Profiler, and what are its main components?</h5>
<p>The Android Profiler is a powerful tool integrated into Android Studio that helps developers monitor the performance of their applications in real time. It provides insights into various aspects of app behavior, such as CPU usage, memory allocation, network activity, and battery consumption.
The main components of the Android Profiler include the CPU Profiler, Memory Profiler, Network Profiler, and Energy Profiler.
The CPU Profiler allows you to analyze how your app utilizes the CPU, helping to identify heavy processing tasks.
The Memory Profiler tracks memory usage over time, enabling you to spot leaks and optimize memory allocation.
The Network Profiler monitors network requests and responses, giving insights into data usage and response times.
Lastly, the Energy Profiler helps you understand your app’s battery usage patterns, making it easier to implement energy-saving measures.</p>
<h5 id="57-how-can-you-use-the-memory-profiler-to-detect-memory-leaks">57. How can you use the Memory Profiler to detect memory leaks?</h5>
<p>The Memory Profiler is an essential tool for identifying memory leaks in Android applications. A memory leak occurs when an application holds onto memory that is no longer needed, leading to increased memory usage and potential app crashes.
To use the Memory Profiler, you first run your app in debug mode, then open the profiler by selecting the “Memory” tab in the Android Profiler window. Here, you can monitor memory allocations in real time, take heap dumps, and analyze retained objects.
To detect memory leaks, initiate a heap dump while your app is running and then analyze the heap dump. In the heap dump, you can inspect the instances of objects and their references. Look for objects that should have been cleared but are still in memory.</p>
<h5 id="58-explain-how-to-use-the-cpu-profiler-to-analyze-app-performance">58. Explain how to use the CPU Profiler to analyze app performance.</h5>
<p>The CPU Profiler is a critical component for analyzing the performance of an Android application, particularly in understanding how effectively your app utilizes CPU resources.
To use the CPU Profiler, run your app in Android Studio, navigate to the “CPU” section of the Android Profiler, and start recording CPU activity. You can select to profile specific processes, such as your app or background services, and choose the recording mode — either “Sampling” for an overview or “Instrumentation” for detailed method tracing.
The profiler displays information on CPU usage over time, highlighting which methods are consuming the most resources. You can drill down into specific method calls and view their execution times, enabling you to identify performance bottlenecks.</p>
<h5 id="59-what-is-strictmode-and-how-can-it-help-in-debugging">59. What is StrictMode, and how can it help in debugging?</h5>
<p>trictMode is a debugging tool provided by Android that helps developers identify and fix issues related to performance and improper usage of the Android framework. When enabled, StrictMode can catch potential problems such as accidental disk writes on the main thread, network operations on the UI thread, and memory leaks. This tool is particularly useful during the development phase, as it enforces best practices and promotes cleaner code by alerting developers to problematic patterns that may lead to a degraded user experience.</p>
<p>To enable StrictMode in your application, you can add the following code in your Application class or Activity&rsquo;s onCreate method:</p>
<p>if (BuildConfig.DEBUG) {
StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
.detectAll()
.penaltyLog()
.build());
StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
.detectLeakedSqlLiteObjects()
.detectLeakedClosableObjects()
.penaltyLog()
.build());
}</p>
<h5 id="60-how-do-you-use-the-network-profiler-and-what-information-can-you-obtain-from-it">60. How do you use the Network Profiler, and what information can you obtain from it?</h5>
<p>The Network Profiler is a valuable tool for monitoring the network activity of your Android application, helping you understand how it consumes data and interacts with web services.
To use the Network Profiler, launch your app in Android Studio, navigate to the “Network” tab in the Android Profiler, and observe real-time network requests made by your app. The profiler displays various metrics such as request size, response size, latency, and the status of each request.
It helps identify large payloads that may slow down app performance and allows you to see the specific endpoints your app is communicating with. You can also check for HTTP errors, such as 404 or 500 status codes, which may indicate issues with your server or API.</p>
<h5 id="61-what-are-some-strategies-you-use-to-identify-and-resolve-anr-application-not-responding-issues">61. What are some strategies you use to identify and resolve ANR (Application Not Responding) issues?</h5>
<p>Application Not Responding (ANR) issues occur when the main thread of an Android application is blocked for too long, typically over 5 seconds.</p>
<p>Using the Android Profiler, particularly the CPU Profiler, can help you monitor thread activity and identify long-running operations. Analyze the stack traces provided in the ANR dialog, which reveal what the main thread was executing at the time of the ANR.
Another effective strategy is to implement asynchronous processing using background threads for long-running tasks.
Additionally, profiling your app’s performance during heavy operations can highlight potential bottlenecks. Implementing a responsive user interface, such as displaying loading indicators or providing user feedback during data processing, can also mitigate the impact of ANRs.</p>
<h5 id="62-how-can-you-debug-a-crash-that-only-happens-in-release-builds">62. How can you debug a crash that only happens in release builds?</h5>
<p>To tackle this issue, start by ensuring you have proper logging in place. Using libraries like Firebase Crashlytics or Sentry can help capture and report crashes in production, providing detailed stack traces and user context to assist in diagnosing the problem.
Additionally, you can implement custom error handling to log exceptions before they cause a crash.
Another approach is to generate a mapping file during the build process, which can help you deobfuscate stack traces from release builds. If you’re using ProGuard or R8 for code shrinking, make sure to keep the mapping files accessible. When a crash occurs, you can use these files to translate obfuscated method names and line numbers back to the original source code, making it easier to pinpoint the cause of the crash.
Finally, consider testing release builds on different devices and configurations to reproduce the issue.</p>
<h5 id="63-what-is-adb-and-how-is-it-useful-in-android-debugging">63. What is ADB, and how is it useful in Android debugging?</h5>
<p>Android Debug Bridge (ADB) is a versatile command-line tool that enables communication between a computer and an Android device or emulator. ADB is particularly useful for debugging because it allows developers to retrieve logs from the device using commands like adb logcat. This command outputs the system logs, including log messages from your application, which can be invaluable for troubleshooting crashes and performance issues. Additionally, ADB provides features for running tests, pushing and pulling files to and from the device, and monitoring app performance, all of which streamline the debugging process.</p>
<h5 id="64-explain-the-process-of-debugging-a-memory-leak-when-dealing-with-the-android-activity-lifecycle">64. Explain the process of debugging a memory leak when dealing with the Android Activity Lifecycle.</h5>
<p>To start, use the Memory Profiler in Android Studio to track memory usage and identify any unusual increases in memory allocation when activities are created and destroyed. When an Activity is paused or destroyed, ensure that it properly cleans up resources, such as unregistering listeners, nullifying references to static objects, and avoiding memory leaks from inner classes.
Taking a heap dump while the application is running can provide further insights into retained objects that should have been cleared. In the heap dump analysis, look for instances of the Activity that should no longer be in memory, as well as any objects that hold references to the Activity. For example, if you see a retained instance of a Fragment or a View that references the Activity, it may indicate a leak.
Additionally, consider using libraries like LeakCanary, which can automatically detect leaks and provide detailed reports, streamlining the debugging process.</p>
<h5 id="65-how-do-you-debug-ui-related-issues-which-tools-do-you-prefer-for-layout-analysis">65. How do you debug UI-related issues? Which tools do you prefer for layout analysis?</h5>
<p>One of the primary tools for layout analysis is the Layout Inspector, which allows you to view and analyze the UI hierarchy in real time while your app is running. With Layout Inspector, you can see how views are arranged, their attributes, and how they interact with each other, making it easier to spot problems like overlapping views or incorrect layouts.
The Constraint Layout editor provides visual feedback on layout constraints, helping you understand how to optimize your UI for different screen sizes.
The UI Automator Viewer allows you to inspect the layout of apps that are not under your control, which is particularly useful when testing against third-party apps.</p>
<h5 id="66-what-is-unit-testing-and-why-is-it-important">66. What is unit testing, and why is it important?</h5>
<p>Unit testing is the process of testing individual components or functions of a software application in isolation to ensure that each part performs as expected. In Android development, unit tests focus on testing small pieces of code, such as methods and classes, without relying on external systems like databases or network resources. The primary goal of unit testing is to validate that each unit of the codebase behaves correctly under various conditions, thus ensuring the reliability of the application.</p>
<h5 id="67-what-are-the-key-principles-of-a-good-unit-test">67. What are the key principles of a good unit test?</h5>
<p>Good unit tests are designed with several key principles in mind, ensuring they are effective and maintainable.</p>
<p>First, isolated: tests should focus on a single unit of work and not depend on other components. This isolation allows for faster execution and more straightforward debugging.
Second, repeatable: tests must produce the same result every time they are run, regardless of the environment or the order in which they are executed. This principle ensures consistency in the testing process.
Third, descriptive: test names should clearly indicate what behavior is being tested, making it easier to understand the intent of the tests at a glance.
Fourth, fast: unit tests should execute quickly to encourage frequent running during development, promoting a continuous integration workflow.
Lastly, good unit tests should be independent, meaning that the outcome of one test should not influence another, allowing for easier pinpointing of issues when a test fails.</p>
<h5 id="68-explain-the-difference-between-unit-testing-integration-testing-and-end-to-end-testing">68. Explain the difference between unit testing, integration testing, and end-to-end testing.</h5>
<p>Unit testing focuses on individual components or functions within the application, ensuring that each unit behaves correctly in isolation. It generally tests small pieces of code, such as methods or classes, without relying on external dependencies.
Integration testing, on the other hand, examines how various components work together. It verifies that different modules or services interact as expected when combined, ensuring that the interfaces between them are functioning correctly. Integration tests may involve interactions with databases, network services, or file systems.
End-to-end testing (E2E testing) tests the entire application workflow from start to finish, simulating user behavior in a real environment. It assesses how the application behaves as a whole, ensuring that all components work together to fulfill business requirements.</p>
<h5 id="69-what-testing-frameworks-are-commonly-used-for-unit-testing-in-android">69. What testing frameworks are commonly used for unit testing in Android?</h5>
<p>JUnit: A foundational framework for writing and running tests in Java, JUnit is commonly used for unit tests in Android applications. It provides annotations and assertions to define and check test conditions.
Mockito: A mocking framework that allows developers to create mock objects for testing. Mockito is particularly useful for isolating unit tests from dependencies, enabling the testing of components in isolation.
Robolectric: This framework enables developers to run Android tests directly in the JVM, eliminating the need for an emulator or physical device. Robolectric provides a simulated Android environment for testing UI components and other Android-specific functionality.
Espresso: While primarily used for UI testing, Espresso can also be used in conjunction with unit tests to validate user interactions and ensure that the UI behaves correctly.
These frameworks can be integrated with build systems like Gradle to streamline the testing process.</p>
<h5 id="70-what-is-mockito-and-how-do-you-use-it-in-android-unit-tests">70. What is Mockito, and how do you use it in Android unit tests?</h5>
<p>Mockito is a popular mocking framework used to create mock objects for testing. It allows developers to simulate the behavior of complex dependencies, enabling unit tests to focus on the logic of the class being tested without relying on actual implementations of its dependencies. This isolation is crucial for ensuring that unit tests are efficient and reliable.</p>
<h5 id="71-how-does-robolectric-work-and-why-is-it-used-in-android-testing">71. How does Robolectric work, and why is it used in Android testing?</h5>
<p>Robolectric is a testing framework that allows developers to run Android tests directly on the JVM (Java Virtual Machine) instead of relying on an emulator or physical device.
This capability significantly speeds up the testing process, as it eliminates the overhead of starting an emulator, allowing developers to run tests quickly during the development cycle.
Robolectric simulates the Android runtime environment, providing access to Android APIs and allowing for the testing of UI components, services, and other application components.
Robolectric achieves this by creating a shadow of the Android classes, which acts as a substitute for the actual classes in the Android framework. This approach allows developers to write unit tests for Android applications in a more straightforward manner.</p>
<h5 id="72-what-are-some-challenges-youve-faced-while-unit-testing-android-apps">72. What are some challenges you’ve faced while unit testing Android apps?</h5>
<p>One common challenge is dealing with the Android framework itself, which can complicate testing due to its reliance on context and system services. For example, components like Activities and Services are tightly integrated with the Android lifecycle, making it challenging to test them in isolation without a robust testing framework like Robolectric.
Another challenge is managing dependencies, particularly when working with classes that require external resources or heavy configurations. These dependencies can lead to complex setup and teardown processes, making tests harder to maintain.
Moreover, asynchronous code, such as network requests or database operations, can introduce timing issues that complicate unit testing. Ensuring that tests run reliably in the face of concurrency and timing can require additional strategies like using mock objects or libraries that facilitate testing of asynchronous tasks.</p>
<h5 id="73-what-is-dependency-injection-and-why-is-it-useful-in-unit-testing">73. What is dependency injection, and why is it useful in unit testing?</h5>
<p>Dependency Injection (DI) is a design pattern that allows a class to receive its dependencies from an external source rather than creating them internally. This approach promotes loose coupling and enhances code modularity, making it easier to manage dependencies.
By using dependency injection, you can easily replace complex or stateful dependencies with simpler, predictable alternatives. For example, if a class requires a network service, you can inject a mock version of that service during tests to control the responses and behavior. This capability enables thorough testing of the class’s logic without interference from the complexities of the actual dependencies, leading to more reliable and maintainable tests.</p>
<h5 id="74-explain-the-difference-between-mock-and-spy-in-mockito">74. Explain the difference between @Mock and @Spy in Mockito.</h5>
<p>The @Mock annotation is used to create a mock instance of a class. A mock is a simulated object that mimics the behavior of a real object but without executing its actual code. When you call methods on a mock, you can define the expected behavior using Mockito’s when and thenReturn methods.
The @Spy annotation is used to create a spy instance of a class. A spy is a partial mock that allows you to call real methods of the object while still being able to verify interactions and change the behavior of specific methods. This is useful when you want to test a class’s behavior but also monitor its interactions.</p>
<h5 id="75-what-are-some-anti-patterns-in-unit-testing-and-how-do-you-avoid-them">75. What are some anti-patterns in unit testing, and how do you avoid them?</h5>
<p>Testing Implementation Details: Focusing too much on the internal workings of a class rather than its behavior can make tests brittle and difficult to maintain. Instead, tests should validate the expected outcomes and behavior from the perspective of the class’s public interface.
Over-Mocking: Creating excessive mocks can lead to tests that are disconnected from the actual behavior of the application. Instead of mocking every dependency, consider using real objects for simpler dependencies or integrating with lightweight versions of complex components.
Too Many Assertions: Having multiple assertions in a single test can make it challenging to identify the cause of a failure. Aim for one assertion per test to improve clarity and focus.
Ignoring Test Failures: Allowing failing tests to persist in the codebase can create technical debt and reduce the confidence in the test suite. Regularly review and maintain tests, removing or fixing any that are no longer relevant or passing.</p>
<h5 id="76-how-do-you-decide-the-naming-conventions-for-test-cases">76. How do you decide the naming conventions for test cases?</h5>
<p>A good naming convention should clearly convey the intent of the test and the specific behavior being validated. A common approach is to use the format methodName_StateUnderTest_ExpectedBehavior, which provides context about what is being tested.</p>
<p>For example, if testing a method called calculateDiscount() in a class called ShoppingCart, a suitable test name might be calculateDiscount_WhenCalledWithValidInput_ReturnsCorrectDiscount(). This name indicates the method being tested, the condition under which it is called, and the expected outcome.</p>
<h5 id="77-how-do-you-use-when-and-verify-statements-in-mockito">77. How do you use when and verify statements in Mockito?</h5>
<p>The when statement is used to define the behavior of a mock object when a specific method is called. This allows you to control what the mock returns or does when invoked. For example:
when(mockedObject.methodCall()).thenReturn(someValue)
The verify statement is used to check whether a particular method was called on a mock object during the test. This is important for ensuring that interactions with the mock occur as expected.
verify(mockedObject).methodCall()</p>
<h5 id="78-can-you-give-examples-of-using-argumentcaptor-in-tests">78. Can you give examples of using ArgumentCaptor in tests?</h5>
<p>ArgumentCaptor is a useful feature in Mockito that allows you to capture arguments passed to mock methods during a test. This can be particularly helpful when you want to verify that a method was called with specific parameters or when you want to manipulate the arguments for further assertions.</p>
<h5 id="thanks-for-reading">Thanks for reading!</h5>
<p>Hope you find this useful. This is just a list of questions I personally found useful in interviews. This list is by no means exhaustive. Let me know your thoughts in the responses. Happy coding!</p>

          </article>
        </div>
      </div>
      <div class="col-sm-12 col-md-12 col-lg-3">
        <div id="stickySideBar" class="sticky-sidebar">
          
          <aside class="toc">
              <h5>
                Table Of Contents
              </h5>
              <div class="toc-content">
                <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav>
              </div>
          </aside>
          

          
          <aside class="tags">
            <h5>Tags</h5>
            <ul class="tags-ul list-unstyled list-inline">
              
              <li class="list-inline-item"><a href="https://whywhom.github.io/tags/android"
                target="_blank"
              >Android</a></li>
              
              <li class="list-inline-item"><a href="https://whywhom.github.io/tags/interview"
                target="_blank"
              >Interview</a></li>
              
            </ul>
          </aside>
          

          
          <aside class="social">
            <h5>Social</h5>
            <div class="social-content">
              <ul class="list-inline">
                <li class="list-inline-item text-center">
                  <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwhywhom.github.io%2fblogs%2fandroid-interview-series-2024-part-2-android-intermediate%2f">
                    <i class="fab fa-linkedin"></i>
                  </a>
                </li>
                <li class="list-inline-item text-center">
                  <a target="_blank" href="https://twitter.com/share?text=Android%20intermediate&url=https%3a%2f%2fwhywhom.github.io%2fblogs%2fandroid-interview-series-2024-part-2-android-intermediate%2f">
                    <i class="fab fa-twitter"></i>
                  </a>
                </li>
                <li class="list-inline-item text-center">
                  <a target="_blank" href="https://api.whatsapp.com/send?text=Android%20intermediate: https%3a%2f%2fwhywhom.github.io%2fblogs%2fandroid-interview-series-2024-part-2-android-intermediate%2f">
                    <i class="fab fa-whatsapp"></i>
                  </a>
                </li>
                <li class="list-inline-item text-center">
                  <a target="_blank" href='mailto:?subject=Android%20intermediate&amp;body=Check%20out%20this%20site https%3a%2f%2fwhywhom.github.io%2fblogs%2fandroid-interview-series-2024-part-2-android-intermediate%2f'>
                    <i class="fa fa-envelope"></i>
                  </a>
                </li>
              </ul>
            </div>
          </aside>
          
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12 col-lg-9 p-4">
        
      </div>
    </div>
  </div>
  <button class="p-2 px-3" onclick="topFunction()" id="topScroll">
    <i class="fas fa-angle-up"></i>
  </button>
</section>


<div class="progress">
  <div id="scroll-progress-bar" class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
</div>
<Script src="/js/scrollProgressBar.js"></script>


<script>
  var topScroll = document.getElementById("topScroll");
  window.onscroll = function() {scrollFunction()};

  function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
      topScroll.style.display = "block";
    } else {
      topScroll.style.display = "none";
    }
  }

  function topFunction() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  }

  
  let stickySideBarElem = document.getElementById("stickySideBar");
  let stickyNavBar =  true ;
  if(stickyNavBar) {
    let headerElem = document.getElementById("profileHeader");
    let headerHeight = headerElem.offsetHeight + 15;
    stickySideBarElem.style.top = headerHeight + "px";
  } else {
    stickySideBarElem.style.top = "50px";
  }
</script>


<script src="/js/readingTime.js"></script>



  </div><footer>
    
 
 
<div class="container py-3" id="recent-posts">
    
    
    <div class="h3 text-center text-secondary py-3">
        Recent Posts
    </div>
    <div class="row justify-content-center">
        
        <div class="col-lg-4 col-md-6 pt-2">
            <div class="card h-100">
                
                <div class="card-header">
                    <a href="/blogs/android-interview-series-2024-part-8-android-architecture/">
                        <img src="https://miro.medium.com/v2/resize:fit:3840/format:webp/0*ovGMYgU7aA9In-oV.jpeg" class="card-img-top" alt="Android architecture">
                    </a>
                </div>
                
                <div class="card-body bg-transparent p-3 shadow-sm">
                    <a href="/blogs/android-interview-series-2024-part-8-android-architecture/" class="primary-font card-title">
                        <h5 class="card-title bg-transparent" title="Android architecture">Android architecture</h5>
                    </a>
                    <div class="card-text secondary-font">
                        <p><p>Here is the original article:</p>
<p><a href="https://proandroiddev.com/android-interview-series-2024-part-8-android-architecture-07ca74eee000">🔗 Android Interview Series 2024 — Part 8 (Android architecture)</a></p>
<p>This article is published on ProAndroidDev and covers essential Android interview topics for 2024. 🚀</p>
<h5 id="1-can-you-explain-the-mvc-and-mvp-patterns-what-are-the-main-differences-and-why-are-they-not-used-in-android-development">1. Can you explain the MVC and MVP patterns? What are the main differences and why are they not used in …</h5></p>
                    </div>
                </div>
                <div class="mt-auto card-footer">
                    <span class="float-start">Nov 3, 2024</span>
                    <a href="/blogs/android-interview-series-2024-part-8-android-architecture/" class="float-end btn btn-outline-info btn-sm">Read</a>
                </div>
            </div>
        </div>
        
        <div class="col-lg-4 col-md-6 pt-2">
            <div class="card h-100">
                
                <div class="card-header">
                    <a href="/blogs/android-interview-series-2024-part-7-jetpack-compose/">
                        <img src="https://miro.medium.com/v2/resize:fit:3840/format:webp/0*ovGMYgU7aA9In-oV.jpeg" class="card-img-top" alt="Jetpack Compose">
                    </a>
                </div>
                
                <div class="card-body bg-transparent p-3 shadow-sm">
                    <a href="/blogs/android-interview-series-2024-part-7-jetpack-compose/" class="primary-font card-title">
                        <h5 class="card-title bg-transparent" title="Jetpack Compose">Jetpack Compose</h5>
                    </a>
                    <div class="card-text secondary-font">
                        <p><p>Here is the original article:</p>
<p><a href="https://proandroiddev.com/android-interview-series-2024-part-7-jetpack-compose-ff7d2ecd9018">🔗 Android Interview Series 2024 — Part 7 (Jetpack Compose)</a></p>
<p>This article is published on ProAndroidDev and covers essential Android interview topics for 2024. 🚀</p>
<h5 id="1-what-is-jetpack-compose">1. What is Jetpack Compose?</h5>
<p>Jetpack Compose is Android’s recommended modern toolkit for building native UI. It …</p></p>
                    </div>
                </div>
                <div class="mt-auto card-footer">
                    <span class="float-start">Oct 3, 2024</span>
                    <a href="/blogs/android-interview-series-2024-part-7-jetpack-compose/" class="float-end btn btn-outline-info btn-sm">Read</a>
                </div>
            </div>
        </div>
        
        <div class="col-lg-4 col-md-6 pt-2">
            <div class="card h-100">
                
                <div class="card-header">
                    <a href="/blogs/android-interview-series-2024-part-6-kotlin-flows/">
                        <img src="https://miro.medium.com/v2/resize:fit:3840/format:webp/0*ovGMYgU7aA9In-oV.jpeg" class="card-img-top" alt="Kotlin Flows">
                    </a>
                </div>
                
                <div class="card-body bg-transparent p-3 shadow-sm">
                    <a href="/blogs/android-interview-series-2024-part-6-kotlin-flows/" class="primary-font card-title">
                        <h5 class="card-title bg-transparent" title="Kotlin Flows">Kotlin Flows</h5>
                    </a>
                    <div class="card-text secondary-font">
                        <p><p>Here is the original article:</p>
<p><a href="https://proandroiddev.com/android-interview-series-2024-part-6-kotlin-flows-730f6bf877df">🔗 Android Interview Series 2024 — Part 6 (Kotlin Flows)</a></p>
<p>This article is published on ProAndroidDev and covers essential Android interview topics for 2024. 🚀</p>
<h5 id="1-what-is-flow">1. What is Flow?</h5>
<p>A stream of data that can be computed asynchronously is referred to as a Flow . It allows you to …</p></p>
                    </div>
                </div>
                <div class="mt-auto card-footer">
                    <span class="float-start">Sep 3, 2024</span>
                    <a href="/blogs/android-interview-series-2024-part-6-kotlin-flows/" class="float-end btn btn-outline-info btn-sm">Read</a>
                </div>
            </div>
        </div>
        
    </div>
</div>


    

    <div class="container py-4">
    <div class="row justify-content-center">
        <div class="col-md-4 text-center">
            
                <div class="pb-2">
                    <a href="https://whywhom.github.io/" title="Andy&#39;s Blog">
                        <img alt="Footer logo" src="/images/andy.jpeg"
                            height="40px" width="40px">
                    </a>
                </div>
            
            &copy; 2025  All rights reserved
            <div class="text-secondary">
                Made with
                <span class="text-danger">
                    &#10084;
                </span>
                and
                <a href="https://github.com/gurusabarish/hugo-profile" target="_blank"
                    title="Designed and developed by gurusabarish">
                    Hugo Profile
                </a>
            </div>
        </div>
    </div>
</div>
</footer><script src="/bootstrap-5/js/bootstrap.bundle.min.js"></script>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl)
    })

</script>


    <script src="/js/search.js"></script>











  <section id="search-content" class="py-2">
    <div class="container" id="search-results"></div>
  </section>
</body>

</html>
